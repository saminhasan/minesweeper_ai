[
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\enum.py",
        "line": 202,
        "func_name": "property.__get__",
        "type_comments": [
            "(game_engine.State, enum.EnumType) -> int"
        ],
        "samples": 500
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\enum.py",
        "line": 1292,
        "func_name": "value",
        "type_comments": [
            "() -> int"
        ],
        "samples": 500
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\queue.py",
        "line": 34,
        "func_name": "Queue.__init__",
        "type_comments": [
            "(int) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 6
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\queue.py",
        "line": 97,
        "func_name": "Queue.empty",
        "type_comments": [
            "() -> bool"
        ],
        "samples": 217
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\queue.py",
        "line": 122,
        "func_name": "Queue.put",
        "type_comments": [
            "(Tuple[Tuple[int, int, float], solver.Reduceable], bool, None) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 216
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\queue.py",
        "line": 154,
        "func_name": "Queue.get",
        "type_comments": [
            "(bool, None) -> Tuple[Tuple[int, int, float], solver.Reduceable]"
        ],
        "samples": 216
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\queue.py",
        "line": 229,
        "func_name": "PriorityQueue._init",
        "type_comments": [
            "(int) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 6
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\queue.py",
        "line": 232,
        "func_name": "PriorityQueue._qsize",
        "type_comments": [
            "() -> int"
        ],
        "samples": 429
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\queue.py",
        "line": 235,
        "func_name": "PriorityQueue._put",
        "type_comments": [
            "(Tuple[Tuple[int, int, float], solver.Reduceable]) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 216
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\queue.py",
        "line": 238,
        "func_name": "PriorityQueue._get",
        "type_comments": [
            "() -> Tuple[Tuple[int, int, float], solver.Reduceable]"
        ],
        "samples": 216
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\random.py",
        "line": 242,
        "func_name": "Random._randbelow_with_getrandbits",
        "type_comments": [
            "(int) -> int"
        ],
        "samples": 7
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\random.py",
        "line": 341,
        "func_name": "Random.choice",
        "type_comments": [
            "(List[Tuple[int, int]]) -> Tuple[int, int]"
        ],
        "samples": 6
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\random.py",
        "line": 359,
        "func_name": "Random.sample",
        "type_comments": [
            "(List[Tuple[int, int]], int, None) -> List[Tuple[int, int]]"
        ],
        "samples": 1
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\threading.py",
        "line": 277,
        "func_name": "Condition.__init__",
        "type_comments": [
            "(_thread.lock) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 8
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\threading.py",
        "line": 299,
        "func_name": "Condition.__enter__",
        "type_comments": [
            "() -> bool"
        ],
        "samples": 427
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\threading.py",
        "line": 302,
        "func_name": "Condition.__exit__",
        "type_comments": [
            "(*None) -> None"
        ],
        "samples": 427
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\threading.py",
        "line": 314,
        "func_name": "Condition._is_owned",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 427
    },
    {
        "path": "C:\\Program Files\\Python\\Python312\\Lib\\threading.py",
        "line": 394,
        "func_name": "Condition.notify",
        "type_comments": [
            "(int) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 427
    },
    {
        "path": "game_engine.py",
        "line": 23,
        "func_name": "TagGenerator.__init__",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 6
    },
    {
        "path": "game_engine.py",
        "line": 28,
        "func_name": "TagGenerator.next_tag",
        "type_comments": [
            "() -> str"
        ],
        "samples": 84
    },
    {
        "path": "game_engine.py",
        "line": 49,
        "func_name": "Minesweeper.__init__",
        "type_comments": [
            "(str) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 1
    },
    {
        "path": "game_engine.py",
        "line": 70,
        "func_name": "Minesweeper.place_mines",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 1
    },
    {
        "path": "game_engine.py",
        "line": 85,
        "func_name": "Minesweeper.reveal",
        "type_comments": [
            "(int, int) -> pyannotate_runtime.collect_types.UnknownType",
            "(int, int) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 14
    },
    {
        "path": "game_engine.py",
        "line": 115,
        "func_name": "Minesweeper.random_safe_reveal",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 6
    },
    {
        "path": "game_engine.py",
        "line": 140,
        "func_name": "Minesweeper.check_win",
        "type_comments": [
            "() -> bool"
        ],
        "samples": 9
    },
    {
        "path": "game_engine.py",
        "line": 151,
        "func_name": "Minesweeper.get_neighbors",
        "type_comments": [
            "(int, int) -> List[Tuple[int, int]]"
        ],
        "samples": 221
    },
    {
        "path": "game_engine.py",
        "line": 160,
        "func_name": "Minesweeper.create_rules_from_minefield",
        "type_comments": [
            "() -> List[solver.Rule]"
        ],
        "samples": 6
    },
    {
        "path": "game_engine.py",
        "line": 193,
        "func_name": "Minesweeper.decode_solution",
        "type_comments": [
            "(Dict[str, float]) -> Tuple[Dict[Tuple[int, int], float], List[List[float]]]"
        ],
        "samples": 6
    },
    {
        "path": "game_engine.py",
        "line": 223,
        "func_name": "Minesweeper.solve_minefield",
        "type_comments": [
            "() -> Tuple[Dict[Tuple[int, int], float], List[List[float]]]"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 35,
        "func_name": "Permutation.__init__",
        "type_comments": [
            "(Set[Tuple[frozenset, int]]) -> pyannotate_runtime.collect_types.NoReturnType",
            "(Dict[frozenset, int]) -> pyannotate_runtime.collect_types.NoReturnType",
            "(generator) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 58
    },
    {
        "path": "solver.py",
        "line": 44,
        "func_name": "Permutation.subset",
        "type_comments": [
            "(frozenset) -> solver.Permutation",
            "(Set[frozenset]) -> solver.Permutation"
        ],
        "samples": 52
    },
    {
        "path": "solver.py",
        "line": 48,
        "func_name": "Permutation.compatible",
        "type_comments": [
            "(solver.Permutation) -> bool"
        ],
        "samples": 27
    },
    {
        "path": "solver.py",
        "line": 54,
        "func_name": "Permutation.combine",
        "type_comments": [
            "(solver.Permutation) -> solver.Permutation"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 65,
        "func_name": "Permutation.k",
        "type_comments": [
            "() -> int"
        ],
        "samples": 8
    },
    {
        "path": "solver.py",
        "line": 69,
        "func_name": "Permutation.cells",
        "type_comments": [
            "() -> Set[frozenset]"
        ],
        "samples": 49
    },
    {
        "path": "solver.py",
        "line": 73,
        "func_name": "Permutation.multiplicity",
        "type_comments": [
            "() -> float"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 82,
        "func_name": "Permutation._canonical",
        "type_comments": [
            "() -> Tuple[Tuple[frozenset, int], Tuple[frozenset, int], Tuple[frozenset, int]]",
            "() -> Tuple[Tuple[frozenset, int], Tuple[frozenset, int]]",
            "() -> Tuple[Tuple[frozenset, int]]"
        ],
        "samples": 83
    },
    {
        "path": "solver.py",
        "line": 100,
        "func_name": "UnchartedCell.__init__",
        "type_comments": [
            "(int) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 106,
        "func_name": "UnchartedCell.__len__",
        "type_comments": [
            "() -> int"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 109,
        "func_name": "UnchartedCell.__iter__",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType",
            "() -> Iterator"
        ],
        "samples": 7
    },
    {
        "path": "solver.py",
        "line": 115,
        "func_name": "UnchartedCell._canonical",
        "type_comments": [
            "() -> Tuple[int]"
        ],
        "samples": 10
    },
    {
        "path": "solver.py",
        "line": 130,
        "func_name": "Rule_.__init__",
        "type_comments": [
            "(int, frozenset, int) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 412
    },
    {
        "path": "solver.py",
        "line": 145,
        "func_name": "Rule_.decompose",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType",
            "() -> Iterator[solver.Rule_]"
        ],
        "samples": 495
    },
    {
        "path": "solver.py",
        "line": 156,
        "func_name": "Rule_.subtract",
        "type_comments": [
            "(solver.Rule_) -> solver.Rule_"
        ],
        "samples": 80
    },
    {
        "path": "solver.py",
        "line": 165,
        "func_name": "Rule_.permute",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType",
            "() -> Iterator[solver.Permutation]"
        ],
        "samples": 10
    },
    {
        "path": "solver.py",
        "line": 170,
        "func_name": "Rule_.is_subrule_of",
        "type_comments": [
            "(solver.Rule_) -> bool"
        ],
        "samples": 500
    },
    {
        "path": "solver.py",
        "line": 178,
        "func_name": "Rule_.is_trivial",
        "type_comments": [
            "() -> bool"
        ],
        "samples": 151
    },
    {
        "path": "solver.py",
        "line": 182,
        "func_name": "Rule_.tally",
        "type_comments": [
            "() -> solver.FrontTally"
        ],
        "samples": 77
    },
    {
        "path": "solver.py",
        "line": 186,
        "func_name": "Rule_._canonical",
        "type_comments": [
            "() -> Tuple[int, frozenset]"
        ],
        "samples": 500
    },
    {
        "path": "solver.py",
        "line": 189,
        "func_name": "Rule_.__repr__",
        "type_comments": [
            "() -> str"
        ],
        "samples": 289
    },
    {
        "path": "solver.py",
        "line": 213,
        "func_name": "PermutedRuleset.__init__",
        "type_comments": [
            "(Set, None) -> pyannotate_runtime.collect_types.NoReturnType",
            "(frozenset, Dict[solver.Rule_, solver.PermutationSet]) -> pyannotate_runtime.collect_types.NoReturnType",
            "(Set[solver.Rule_], None) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 7
    },
    {
        "path": "solver.py",
        "line": 228,
        "func_name": "rule_permuset",
        "type_comments": [
            "(solver.Rule_) -> solver.PermutationSet"
        ],
        "samples": 8
    },
    {
        "path": "solver.py",
        "line": 234,
        "func_name": "PermutedRuleset.cross_eliminate",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 267,
        "func_name": "PermutedRuleset.rereduce",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 302,
        "func_name": "PermutedRuleset.remove_rule",
        "type_comments": [
            "(solver.Rule_) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 5
    },
    {
        "path": "solver.py",
        "line": 307,
        "func_name": "PermutedRuleset.add_permu_set",
        "type_comments": [
            "(solver.PermutationSet) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 5
    },
    {
        "path": "solver.py",
        "line": 314,
        "func_name": "PermutedRuleset.filter",
        "type_comments": [
            "(frozenset) -> solver.PermutedRuleset"
        ],
        "samples": 5
    },
    {
        "path": "solver.py",
        "line": 319,
        "func_name": "PermutedRuleset.split_fronts",
        "type_comments": [
            "() -> Set[solver.PermutedRuleset]",
            "() -> Set"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 325,
        "func_name": "PermutedRuleset.is_trivial",
        "type_comments": [
            "() -> bool"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 329,
        "func_name": "PermutedRuleset.trivial_rule",
        "type_comments": [
            "() -> solver.Rule_"
        ],
        "samples": 5
    },
    {
        "path": "solver.py",
        "line": 339,
        "func_name": "PermutedRuleset.enumerate",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType",
            "() -> Iterator[solver.Permutation]"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 353,
        "func_name": "FrontTally.__init__",
        "type_comments": [
            "(Dict[int, solver.FrontSubtally]) -> pyannotate_runtime.collect_types.NoReturnType",
            "(None) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 79
    },
    {
        "path": "solver.py",
        "line": 360,
        "func_name": "FrontTally.tally",
        "type_comments": [
            "(solver.PermutedRuleset) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 5
    },
    {
        "path": "solver.py",
        "line": 377,
        "func_name": "FrontTally.finalize",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 5
    },
    {
        "path": "solver.py",
        "line": 383,
        "func_name": "FrontTally.min_mines",
        "type_comments": [
            "() -> int"
        ],
        "samples": 78
    },
    {
        "path": "solver.py",
        "line": 387,
        "func_name": "FrontTally.max_mines",
        "type_comments": [
            "() -> int"
        ],
        "samples": 151
    },
    {
        "path": "solver.py",
        "line": 391,
        "func_name": "FrontTally.is_static",
        "type_comments": [
            "() -> bool"
        ],
        "samples": 78
    },
    {
        "path": "solver.py",
        "line": 396,
        "func_name": "FrontTally.__iter__",
        "type_comments": [
            "() -> dict_itemiterator"
        ],
        "samples": 5
    },
    {
        "path": "solver.py",
        "line": 399,
        "func_name": "FrontTally.normalize",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 79
    },
    {
        "path": "solver.py",
        "line": 408,
        "func_name": "FrontTally.collapse",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType",
            "() -> Iterator[Tuple[solver.UnchartedCell, float]]",
            "() -> Iterator[Tuple[frozenset, float]]"
        ],
        "samples": 155
    },
    {
        "path": "solver.py",
        "line": 434,
        "func_name": "FrontTally.update_weights",
        "type_comments": [
            "(Dict[int, float]) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 5
    },
    {
        "path": "solver.py",
        "line": 442,
        "func_name": "from_rule",
        "type_comments": [
            "(solver.Rule_) -> solver.FrontTally"
        ],
        "samples": 77
    },
    {
        "path": "solver.py",
        "line": 455,
        "func_name": "for_other",
        "type_comments": [
            "(int, Dict[int, float]) -> solver.FrontTally"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 490,
        "func_name": "Rule.__init__",
        "type_comments": [
            "(int, List[str]) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 145
    },
    {
        "path": "solver.py",
        "line": 494,
        "func_name": "Rule.condensed",
        "type_comments": [
            "(Dict[solver.Rule, frozenset]) -> solver.Rule_"
        ],
        "samples": 145
    },
    {
        "path": "solver.py",
        "line": 505,
        "func_name": "Rule._canonical",
        "type_comments": [
            "() -> Tuple[int, frozenset]"
        ],
        "samples": 500
    },
    {
        "path": "solver.py",
        "line": 515,
        "func_name": "solve",
        "type_comments": [
            "(List[solver.Rule], solver.MineCount, None) -> Dict[str, float]"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 553,
        "func_name": "condense_supercells",
        "type_comments": [
            "(List[solver.Rule]) -> Tuple[List[solver.Rule_], List[frozenset]]"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 589,
        "func_name": "reduce_rules",
        "type_comments": [
            "(List[solver.Rule_]) -> Set[solver.Rule_]"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 601,
        "func_name": "Reduceable.__init__",
        "type_comments": [
            "(solver.Rule_, solver.Rule_) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 216
    },
    {
        "path": "solver.py",
        "line": 605,
        "func_name": "Reduceable.__lt__",
        "type_comments": [
            "(solver.Reduceable) -> bool"
        ],
        "samples": 500
    },
    {
        "path": "solver.py",
        "line": 610,
        "func_name": "Reduceable.metric",
        "type_comments": [
            "() -> Tuple[int, int, float]"
        ],
        "samples": 500
    },
    {
        "path": "solver.py",
        "line": 626,
        "func_name": "Reduceable.reduce",
        "type_comments": [
            "() -> solver.Rule_"
        ],
        "samples": 80
    },
    {
        "path": "solver.py",
        "line": 633,
        "func_name": "Reduceable.contained_within",
        "type_comments": [
            "(Set[solver.Rule_]) -> bool"
        ],
        "samples": 216
    },
    {
        "path": "solver.py",
        "line": 636,
        "func_name": "Reduceable._canonical",
        "type_comments": [
            "() -> Tuple[solver.Rule_, solver.Rule_]"
        ],
        "samples": 500
    },
    {
        "path": "solver.py",
        "line": 646,
        "func_name": "CellRulesMap.__init__",
        "type_comments": [
            "(frozenset) -> pyannotate_runtime.collect_types.NoReturnType",
            "(List) -> pyannotate_runtime.collect_types.NoReturnType",
            "(Set[solver.Rule_]) -> pyannotate_runtime.collect_types.NoReturnType",
            "(Set) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 8
    },
    {
        "path": "solver.py",
        "line": 653,
        "func_name": "CellRulesMap.add_rules",
        "type_comments": [
            "(frozenset) -> pyannotate_runtime.collect_types.NoReturnType",
            "(List) -> pyannotate_runtime.collect_types.NoReturnType",
            "(Set[solver.Rule_]) -> pyannotate_runtime.collect_types.NoReturnType",
            "(Set) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 8
    },
    {
        "path": "solver.py",
        "line": 657,
        "func_name": "CellRulesMap.add_rule",
        "type_comments": [
            "(solver.Rule_) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 283
    },
    {
        "path": "solver.py",
        "line": 662,
        "func_name": "CellRulesMap.remove_rule",
        "type_comments": [
            "(solver.Rule_) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 80
    },
    {
        "path": "solver.py",
        "line": 667,
        "func_name": "CellRulesMap.overlapping_rules",
        "type_comments": [
            "(solver.Rule_) -> Set[solver.Rule_]",
            "(solver.Rule_) -> Set"
        ],
        "samples": 289
    },
    {
        "path": "solver.py",
        "line": 675,
        "func_name": "CellRulesMap.interference_edges",
        "type_comments": [
            "() -> Set[Tuple[solver.Rule_, solver.Rule_]]",
            "() -> Set"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 680,
        "func_name": "_interference_edges",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType",
            "() -> Iterator[Tuple[solver.Rule_, solver.Rule_]]"
        ],
        "samples": 8
    },
    {
        "path": "solver.py",
        "line": 687,
        "func_name": "CellRulesMap.partition",
        "type_comments": [
            "() -> Set[frozenset]",
            "() -> Set"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 707,
        "func_name": "CellRulesMap.cells_",
        "type_comments": [
            "() -> frozenset"
        ],
        "samples": 7
    },
    {
        "path": "solver.py",
        "line": 718,
        "func_name": "RuleReducer.__init__",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 726,
        "func_name": "RuleReducer.add_rules",
        "type_comments": [
            "(List[solver.Rule_]) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 731,
        "func_name": "RuleReducer.add_rule",
        "type_comments": [
            "(solver.Rule_) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 221
    },
    {
        "path": "solver.py",
        "line": 736,
        "func_name": "RuleReducer.add_base_rule",
        "type_comments": [
            "(solver.Rule_) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 279
    },
    {
        "path": "solver.py",
        "line": 742,
        "func_name": "RuleReducer.add_reduceable",
        "type_comments": [
            "(solver.Reduceable) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 216
    },
    {
        "path": "solver.py",
        "line": 747,
        "func_name": "RuleReducer.update_reduceables",
        "type_comments": [
            "(solver.Rule_) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 279
    },
    {
        "path": "solver.py",
        "line": 757,
        "func_name": "RuleReducer.remove_rule",
        "type_comments": [
            "(solver.Rule_) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 80
    },
    {
        "path": "solver.py",
        "line": 765,
        "func_name": "RuleReducer.pop_best_reduction",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType",
            "() -> solver.Reduceable"
        ],
        "samples": 81
    },
    {
        "path": "solver.py",
        "line": 774,
        "func_name": "RuleReducer.reduce",
        "type_comments": [
            "(solver.Reduceable) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 80
    },
    {
        "path": "solver.py",
        "line": 780,
        "func_name": "RuleReducer.reduce_all",
        "type_comments": [
            "() -> Set[solver.Rule_]"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 790,
        "func_name": "permute",
        "type_comments": [
            "(int, List[frozenset], Set) -> pyannotate_runtime.collect_types.UnknownType",
            "(int, List[frozenset], None) -> pyannotate_runtime.collect_types.UnknownType",
            "(int, List[frozenset], Set[Tuple[frozenset, int]]) -> Iterator[solver.Permutation]",
            "(int, List[frozenset], Set[Tuple[frozenset, int]]) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 18
    },
    {
        "path": "solver.py",
        "line": 802,
        "func_name": "permu_add",
        "type_comments": [
            "(*Tuple[frozenset, int]) -> Set[Tuple[frozenset, int]]"
        ],
        "samples": 13
    },
    {
        "path": "solver.py",
        "line": 834,
        "func_name": "PermutationSet.__init__",
        "type_comments": [
            "(frozenset, int, Set[solver.Permutation]) -> pyannotate_runtime.collect_types.NoReturnType",
            "(frozenset, int, frozenset) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 17
    },
    {
        "path": "solver.py",
        "line": 853,
        "func_name": "from_rule",
        "type_comments": [
            "(solver.Rule_) -> solver.PermutationSet"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 858,
        "func_name": "PermutationSet.to_rule",
        "type_comments": [
            "() -> solver.Rule_"
        ],
        "samples": 5
    },
    {
        "path": "solver.py",
        "line": 866,
        "func_name": "PermutationSet.__iter__",
        "type_comments": [
            "() -> set_iterator"
        ],
        "samples": 12
    },
    {
        "path": "solver.py",
        "line": 874,
        "func_name": "PermutationSet.remove",
        "type_comments": [
            "(solver.Permutation) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 5
    },
    {
        "path": "solver.py",
        "line": 880,
        "func_name": "PermutationSet.empty",
        "type_comments": [
            "() -> bool"
        ],
        "samples": 13
    },
    {
        "path": "solver.py",
        "line": 884,
        "func_name": "PermutationSet.compatible",
        "type_comments": [
            "(solver.Permutation) -> solver.PermutationSet"
        ],
        "samples": 14
    },
    {
        "path": "solver.py",
        "line": 891,
        "func_name": "PermutationSet.subset",
        "type_comments": [
            "(frozenset) -> pyannotate_runtime.collect_types.NoReturnType",
            "(frozenset) -> solver.PermutationSet"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 901,
        "func_name": "PermutationSet.decompose",
        "type_comments": [
            "() -> List[solver.PermutationSet]"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 906,
        "func_name": "PermutationSet._decompose",
        "type_comments": [
            "(int) -> pyannotate_runtime.collect_types.UnknownType",
            "(int) -> List[solver.PermutationSet]"
        ],
        "samples": 4
    },
    {
        "path": "solver.py",
        "line": 929,
        "func_name": "PermutationSet.split",
        "type_comments": [
            "(frozenset) -> pyannotate_runtime.collect_types.NoReturnType",
            "(frozenset) -> Tuple[solver.PermutationSet, solver.PermutationSet]"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 963,
        "func_name": "permute_and_interfere",
        "type_comments": [
            "(Set[solver.Rule_]) -> solver.PermutedRuleset",
            "(Set) -> solver.PermutedRuleset"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 976,
        "func_name": "EnumerationState.__init__",
        "type_comments": [
            "(solver.PermutedRuleset) -> pyannotate_runtime.collect_types.NoReturnType",
            "(None) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 7
    },
    {
        "path": "solver.py",
        "line": 1000,
        "func_name": "EnumerationState.clone",
        "type_comments": [
            "() -> solver.EnumerationState"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1011,
        "func_name": "EnumerationState.build_compatibility_index",
        "type_comments": [
            "(Dict[solver.Rule_, solver.PermutationSet]) -> Dict[Tuple[solver.Permutation, solver.Rule_], solver.PermutationSet]"
        ],
        "samples": 5
    },
    {
        "path": "solver.py",
        "line": 1022,
        "func_name": "EnumerationState.is_complete",
        "type_comments": [
            "() -> bool"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1027,
        "func_name": "EnumerationState.__iter__",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType",
            "() -> Iterator[solver.EnumerationState]"
        ],
        "samples": 7
    },
    {
        "path": "solver.py",
        "line": 1039,
        "func_name": "EnumerationState.propogate",
        "type_comments": [
            "(solver.Rule_, solver.Permutation) -> solver.EnumerationState"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1045,
        "func_name": "EnumerationState._propogate",
        "type_comments": [
            "(solver.Rule_, solver.Permutation) -> pyannotate_runtime.collect_types.UnknownType",
            "(solver.Rule_, solver.Permutation) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 7
    },
    {
        "path": "solver.py",
        "line": 1076,
        "func_name": "EnumerationState.mine_config",
        "type_comments": [
            "() -> solver.Permutation"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1081,
        "func_name": "EnumerationState.enumerate",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.UnknownType",
            "() -> Iterator[solver.Permutation]",
            "() -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 8
    },
    {
        "path": "solver.py",
        "line": 1094,
        "func_name": "FrontSubtally.__init__",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 80
    },
    {
        "path": "solver.py",
        "line": 1107,
        "func_name": "FrontSubtally.add",
        "type_comments": [
            "(solver.Permutation) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1114,
        "func_name": "FrontSubtally.finalize",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1122,
        "func_name": "FrontSubtally.collapse",
        "type_comments": [
            "() -> pyannotate_runtime.collect_types.NoReturnType",
            "() -> Iterator[Tuple[solver.UnchartedCell, float]]",
            "() -> Iterator[Tuple[frozenset, float]]"
        ],
        "samples": 158
    },
    {
        "path": "solver.py",
        "line": 1130,
        "func_name": "mk",
        "type_comments": [
            "(int, Dict[frozenset, int]) -> solver.FrontSubtally",
            "(float, Dict[solver.UnchartedCell, int]) -> solver.FrontSubtally",
            "(float, Dict[frozenset, int]) -> solver.FrontSubtally"
        ],
        "samples": 79
    },
    {
        "path": "solver.py",
        "line": 1145,
        "func_name": "enumerate_front",
        "type_comments": [
            "(solver.PermutedRuleset) -> solver.FrontTally"
        ],
        "samples": 5
    },
    {
        "path": "solver.py",
        "line": 1157,
        "func_name": "cell_probabilities",
        "type_comments": [
            "(Set[solver.FrontTally], solver.MineCount, List[frozenset]) -> itertools.chain"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1175,
        "func_name": "weight_subtallies",
        "type_comments": [
            "(Set[solver.FrontTally], solver.MineCount, List[frozenset]) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1225,
        "func_name": "check_count_consistency",
        "type_comments": [
            "(Set[solver.FrontTally], solver.MineCount, List[frozenset]) -> int"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1257,
        "func_name": "FrontPerMineTotals.__init__",
        "type_comments": [
            "(Dict[int, float]) -> pyannotate_runtime.collect_types.NoReturnType",
            "(Dict[int, int]) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 14
    },
    {
        "path": "solver.py",
        "line": 1261,
        "func_name": "singleton",
        "type_comments": [
            "(int, float) -> solver.FrontPerMineTotals"
        ],
        "samples": 7
    },
    {
        "path": "solver.py",
        "line": 1265,
        "func_name": "total_count",
        "type_comments": [
            "() -> float",
            "() -> int"
        ],
        "samples": 7
    },
    {
        "path": "solver.py",
        "line": 1270,
        "func_name": "FrontPerMineTotals.multiply",
        "type_comments": [
            "(int) -> solver.FrontPerMineTotals",
            "(float) -> solver.FrontPerMineTotals"
        ],
        "samples": 8
    },
    {
        "path": "solver.py",
        "line": 1276,
        "func_name": "sum",
        "type_comments": [
            "(Tuple[solver.FrontPerMineTotals]) -> solver.FrontPerMineTotals",
            "(Tuple[solver.FrontPerMineTotals, solver.FrontPerMineTotals, solver.FrontPerMineTotals]) -> solver.FrontPerMineTotals",
            "(Tuple[solver.FrontPerMineTotals, solver.FrontPerMineTotals]) -> solver.FrontPerMineTotals"
        ],
        "samples": 7
    },
    {
        "path": "solver.py",
        "line": 1281,
        "func_name": "FrontPerMineTotals.__iter__",
        "type_comments": [
            "() -> dict_itemiterator"
        ],
        "samples": 12
    },
    {
        "path": "solver.py",
        "line": 1292,
        "func_name": "AllFrontsPerMineTotals.__init__",
        "type_comments": [
            "(List[solver.FrontPerMineTotals]) -> pyannotate_runtime.collect_types.NoReturnType",
            "(List) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 13
    },
    {
        "path": "solver.py",
        "line": 1296,
        "func_name": "total_count",
        "type_comments": [
            "() -> float",
            "() -> pyannotate_runtime.collect_types.NoReturnType",
            "() -> int"
        ],
        "samples": 8
    },
    {
        "path": "solver.py",
        "line": 1306,
        "func_name": "null",
        "type_comments": [
            "() -> solver.AllFrontsPerMineTotals"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1310,
        "func_name": "singleton",
        "type_comments": [
            "(int, float) -> solver.AllFrontsPerMineTotals"
        ],
        "samples": 7
    },
    {
        "path": "solver.py",
        "line": 1314,
        "func_name": "AllFrontsPerMineTotals.join_with",
        "type_comments": [
            "(solver.AllFrontsPerMineTotals) -> solver.AllFrontsPerMineTotals"
        ],
        "samples": 7
    },
    {
        "path": "solver.py",
        "line": 1322,
        "func_name": "sum",
        "type_comments": [
            "(List[solver.AllFrontsPerMineTotals]) -> solver.AllFrontsPerMineTotals"
        ],
        "samples": 7
    },
    {
        "path": "solver.py",
        "line": 1329,
        "func_name": "AllFrontsPerMineTotals.__iter__",
        "type_comments": [
            "() -> list_iterator"
        ],
        "samples": 7
    },
    {
        "path": "solver.py",
        "line": 1341,
        "func_name": "CombinedFront.__init__",
        "type_comments": [
            "(Dict[int, solver.AllFrontsPerMineTotals]) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 9
    },
    {
        "path": "solver.py",
        "line": 1348,
        "func_name": "min_max_mines",
        "type_comments": [
            "() -> Tuple[int, int]"
        ],
        "samples": 8
    },
    {
        "path": "solver.py",
        "line": 1353,
        "func_name": "null",
        "type_comments": [
            "() -> solver.CombinedFront"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1358,
        "func_name": "from_counts_per_num_mines",
        "type_comments": [
            "(generator) -> solver.CombinedFront"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1368,
        "func_name": "from_tally",
        "type_comments": [
            "(solver.FrontTally) -> solver.CombinedFront"
        ],
        "samples": 5
    },
    {
        "path": "solver.py",
        "line": 1375,
        "func_name": "for_other",
        "type_comments": [
            "(int, int, int, int) -> solver.CombinedFront"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1389,
        "func_name": "CombinedFront.join_with",
        "type_comments": [
            "(solver.CombinedFront, int, int, int) -> solver.CombinedFront"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1401,
        "func_name": "cross_entry",
        "type_comments": [
            "(Tuple[Tuple[int, solver.AllFrontsPerMineTotals], Tuple[int, solver.AllFrontsPerMineTotals]]) -> Tuple[int, solver.AllFrontsPerMineTotals]",
            "(Tuple[Tuple[int, solver.AllFrontsPerMineTotals], Tuple[int, solver.AllFrontsPerMineTotals]]) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 8
    },
    {
        "path": "solver.py",
        "line": 1422,
        "func_name": "CombinedFront.collapse",
        "type_comments": [
            "() -> List[Dict[int, float]]"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1427,
        "func_name": "CombinedFront.__iter__",
        "type_comments": [
            "() -> dict_itemiterator"
        ],
        "samples": 8
    },
    {
        "path": "solver.py",
        "line": 1434,
        "func_name": "relative_likelihood",
        "type_comments": [
            "(int, int, int) -> float"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1442,
        "func_name": "combine_fronts",
        "type_comments": [
            "(Set, int, int) -> solver.FrontTally",
            "(Set[solver.FrontTally], int, int) -> solver.FrontTally"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1490,
        "func_name": "possible_mine_limits",
        "type_comments": [
            "(Set[solver.FrontTally]) -> generator",
            "(Set) -> generator"
        ],
        "samples": 7
    },
    {
        "path": "solver.py",
        "line": 1517,
        "func_name": "discrete_relative_likelihood",
        "type_comments": [
            "(int, int, int) -> float"
        ],
        "samples": 6
    },
    {
        "path": "solver.py",
        "line": 1539,
        "func_name": "expand_cells",
        "type_comments": [
            "(itertools.chain, None) -> pyannotate_runtime.collect_types.NoReturnType",
            "(itertools.chain, None) -> Iterator[Tuple[None, float]]",
            "(itertools.chain, None) -> Iterator[Tuple[str, float]]"
        ],
        "samples": 86
    },
    {
        "path": "util.py",
        "line": 7,
        "func_name": "fact_div",
        "type_comments": [
            "(int, int) -> int",
            "(int, int) -> pyannotate_runtime.collect_types.UnknownType"
        ],
        "samples": 10
    },
    {
        "path": "util.py",
        "line": 12,
        "func_name": "choose",
        "type_comments": [
            "(int, int) -> float",
            "(int, int) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 82
    },
    {
        "path": "util.py",
        "line": 23,
        "func_name": "peek",
        "type_comments": [
            "(frozenset) -> frozenset",
            "(Dict[solver.Rule_, Set[solver.Permutation]]) -> solver.Rule_"
        ],
        "samples": 81
    },
    {
        "path": "util.py",
        "line": 31,
        "func_name": "product",
        "type_comments": [
            "(range) -> int",
            "(generator) -> pyannotate_runtime.collect_types.UnknownType"
        ],
        "samples": 11
    },
    {
        "path": "util.py",
        "line": 43,
        "func_name": "graph_traverse",
        "type_comments": [
            "(Dict[solver.Rule_, Union[Set, Set[solver.Rule_]]], solver.Rule_) -> Set[solver.Rule_]",
            "(Dict[solver.Rule_, Set[solver.Rule_]], solver.Rule_) -> Set[solver.Rule_]"
        ],
        "samples": 5
    },
    {
        "path": "util.py",
        "line": 48,
        "func_name": "_graph_traverse",
        "type_comments": [
            "(solver.Rule_) -> pyannotate_runtime.collect_types.UnknownType",
            "(solver.Rule_) -> pyannotate_runtime.collect_types.NoReturnType"
        ],
        "samples": 6
    },
    {
        "path": "util.py",
        "line": 58,
        "func_name": "map_reduce",
        "type_comments": [
            "(List[Tuple[int, solver.AllFrontsPerMineTotals]], function, function) -> pyannotate_runtime.collect_types.UnknownType",
            "(dict_itemiterator, function, type) -> Dict[solver.Rule, frozenset]",
            "(dict_itemiterator, function, type) -> Dict[frozenset, frozenset]",
            "(Tuple[solver.FrontPerMineTotals], function, builtin_function_or_method) -> Dict[int, float]",
            "(List[solver.Rule], function, type) -> Dict[str, frozenset]",
            "(Tuple[solver.FrontPerMineTotals, solver.FrontPerMineTotals], function, builtin_function_or_method) -> Dict[int, float]",
            "(List[solver.FrontSubtally], function, builtin_function_or_method) -> Dict[frozenset, float]",
            "(Set[solver.Permutation], function, function) -> Dict[solver.Permutation, frozenset]"
        ],
        "samples": 88
    },
    {
        "path": "util.py",
        "line": 85,
        "func_name": "ImmutableMixin.__eq__",
        "type_comments": [
            "(solver.Rule) -> bool",
            "(solver.Reduceable) -> pyannotate_runtime.collect_types.UnknownType",
            "(solver.Rule_) -> bool",
            "(solver.Permutation) -> bool"
        ],
        "samples": 500
    },
    {
        "path": "util.py",
        "line": 91,
        "func_name": "ImmutableMixin.__hash__",
        "type_comments": [
            "() -> int"
        ],
        "samples": 500
    }
]